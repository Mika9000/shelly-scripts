# Water heater controller

Synopsis: Shelly script pair to control an electric hot water heater in a solar panel equipped household.

**But**, in addition to merely switching the heating on when the sun shines, they do the following:

1. In the morning, the system wakes up, heating the water when the power generated by the solar panel system exceeds the power requirement of the heater. When the heater&apos;s thermostat opens or the allowed heating time has been used up, the heating is marked as finished and turns off for the rest of the day.
2. At noon (all times are configurable), if the heating is not yet ready, the solar power requirement is significantly reduced. Smaller expectation ensures that the solar energy cover at least hopefully a good part of the energy used by the water heater, even if the rest is consumed from the grid.
3. In the evening, if the heating is not ready, the script starts monitoring the electricity price and turns on the heating at the cheapest time. Price status is fetched from [spot-hinta.fi](https://spot-hinta.fi/)
4. At night, just before the morning, if the heating was not completed because there weren&apos;t enough cheap hours or the price monitoring wasn&apos;t used, the heating is forced on until completed, regardless of the energy price.
5. Heating can be controlled manually: It can be paused, continued or put back to automatic by manipulating a key in the Shelly&apos;s KVS bank.

# Hardware and API requirements

The following is needed:

- Surprisingly, an electric water heater, one that usually is heated once per day
- A Shelly switch that supports scripting, eg. Shelly Pro 1
- An energy meter, eg. Shelly EM, for measuring water heater&apos;s power consumption
- API for fetching the amount of available solar power. It can be the solar panel system&apos;s API, a Shelly energy meter, a HAN port reader, etc.
- API for fetching electricity price status cheap/not cheap (optional)

One can also use an energy meter that supports scripting and has contactor control, eg. Shelly Pro EM. In that case, Shelly Switch is not needed, as the energy meter can take care of its functions.

APIs must be queryable with a simple HTTP GET method.

# Electrical connections

A licensed electrician understands these

- Output relay of the Shelly switch controls the water heater&apos;s contactor
- Water heater energy meter: Measuring the consumption from just one phase is sufficient even if the heater uses more than one phase; measuring all phases will just give a more accurate result. Note: Use energy meter with current transformers because there are a lot of amps to handle.

# Scripts and their configuration

The software consists of two Shelly scripts: **Heater-Reader** and **Heater-Control**, and they run on a switch that controls the water heater&apos;s contactor.

The **CONFIG** element at the beginning of each script contains settings that are configurable by the user. Other parts should not be tampered with unless instructed.

Example values are taken from my own setup, and they might be suitable to start experimenting with:
- Shelly Pro 1PM controlling the water heater&apos;s contactor (PM feature is not used)
- 3.5kW three-phase hot water heater, with Shelly EM measuring power consumption from one phase
- 6kW solar panel system (previously its API, GEF Vision, was used to get the power reading)
- HAN port reader (CTEK Nanogrid Air) attached to the electricity meter that monitors real time power usage

## Heater-Reader script

### Description
This is the timer and data query component. It times and synchronises the operation and calls API endpoints and the heater-control script.

The script fetches the amount of energy available, water heater power consumption, low electricity price status, and marks scheduled events. Once it has collected the data, it calls the heater-control script and passes it the values.

Copy and paste the code into the first script slot (id 1) of the Shelly. Adjust script&apos;s CONFIG parameters to match the environment.

### **CONFIG** parameters

Example:

```javascript
let CONFIG = {
  endpointlist: [
    //{keyname: 'solar', url: 'https://vision.gef.fi/api/v1/plant/yourapikeyhere/' }, //GEF Vision
    {keyname: 'netproduction', url: 'http://192.168.2.121/meter/' },  //Nanogrid AIR
    {keyname: 'heater', url: 'http://192.168.2.11/emeter/0' }, //Shelly EM
    {keyname: 'cheap', url: 'http://api.spot-hinta.fi/JustNowRank/3'}
  ],
  
  kvsControlKey: 'readsetcompleted',
  controlScriptUrl: 'http://192.168.2.10/script/2/controlcommand',  //Url, script id and endpoint name
  
  dayBegins: '08:00',           //Control wakes up expecting full solar power
  partialPowerBegins: '12:00',  //Partial power level is in use
  priceControlBegins: '17:00',  //Cheap energy hours are monitored
  forcedHeatingBegins: '05:00', //Heating is forced on regardless of energy price
  
  heaterPhaseMultiplier: 3,     //Heater uses 3 phases, only 1 is measured
  invalidReading: 9999,         //Greater than any value ever could be
  
  schedule: {
    kvsKey: "Reader-Schedule-" + JSON.stringify(Shelly.getCurrentScriptId()),
    timespec: "0 */5 * * * *",  //Run at 5 minute intervals
    id: -1 
  }
};
```

**endpointlist**

List of endpoints the script will call when fetching new readings. Each item consists of a keyname and an url to be called. Keyname should not be changed as it is used internally to track which call is which. **Note:** Do not use *solar* and *netproduction* endpoints at the same time, if *netproduction* is defined it will overwrite the value *solar* endpoint returned.

**Endpoint keyname: 'solar'**

Solar panel endpoint that returns the amount of power they produce, in watts.

Use this if the API returns the power currently being produced and not the net yield. When this method is used, an estimated household&apos;s base power consumption must be set to the control script&apos;s **baseConsumption** parameter. Do not use if *netproduction* endpoint is also defined.

Example uses GEF Vision solar panel API. It returns the solar power reading in *power.production* element. Since the value is not a net yield, the control script&apos;s **baseConsumption** parameter must also be set. How the API&apos;s response is handled in the queryResponse function:

`result = parseInt(st.power.production);  //GEF Vision current power`

**Endpoint keyname: 'netproduction'**

Electricity meter endpoint that returns the amount of available power (net yield), in Watts.

This example uses a HAN port reader (CTEK Nanogrid Air) attached to the electricity meter&apos;s port that monitors real time power usage and production. If yours is same you only need to set the IP address. Otherwise, you must change the url and alter the part in the function **QueryResponse** where the response for *netproduction* keyname is handled. Do not use *solar* endpoint if this endpoint is defined.

Nanogrid&apos;s interface has two fields containing power values, *activePowerOut* and *activePowerIn*, and they are in kilowatts. How this response is handled in the queryResponse function:

`result = parseInt((st.activePowerOut - st.activePowerIn)*1000); //Nanogrid, calculate net production and convert kW to W`


**Endpoint keyname: 'heater'**

Energy meter endpoint that returns the water heater&apos;s power consumption. Url must include full path including the channel.

Value needed is the amount of power the heater is currently consuming, in Watts.

In the example, only one phase is measured, even though the water heater is a three-phase model, so the value is multiplied by the number of phases to get the actual consumption. The multiplier is located in the **heaterPhaseMultiplier** setting. How the API&apos;s response is handled in the queryResponse function:

`result = parseInt(st.power * CONFIG.heaterPhaseMultiplier); //Shelly EM, with a multiplier to form a correct reading`

**Endpoint keyname: 'cheap'**

[spot-hinta.fi](https://spot-hinta.fi/) electricity spot price API *'is now a cheap hour'* endpoint. Last value in the url indicates number of cheap hours required, and it should be equal to the maximum allowed heating time. See the Control script&apos;s CONFIG parameter **heatingTime**.

Call returns response code 200 OK if the current hour belongs to the cheap hours, and 400 Bad Response if it doesn&apos;t. Use of this endpoint is optional and can be removed from the list if not needed.

**kvsControlKey**

Name of the key in KVS bank where the state of the heating is maintained (0 auto, 1 completed/manually stopped, 2 manually started). Keyname should not be changed.

**controlScriptUrl**

Url of the heater-control script that this script calls. It must include the script id and the endpoint name.

**dayBegins**

Time when the heater-control script is awakened and prepared to expect full heating power from the solar panel array (all clock times are 24hrs).

**partialPowerBegins**

Time when the reduced solar panel output level takes effect. See also the Control script&apos;s CONFIG parameter **powerLower**.

**priceControlBegins**

Time after which electricity price is monitored and cheap energy hours turn heating on. Setting takes effect only if the heating is not yet complete.

**forcedHeatingBegins**

Time after which heating is forced on regardless of energy price. Setting takes effect only if the heating is not yet complete. Set the value so that the heating is finished before the next day begins. It is calculated by taking this script&apos;s **dayBegins** value and subtracting the max heating time in control script&apos;s **heatingTime** parameter from it.

**heaterPhaseMultiplier**

The factor by which the water heater&apos;s power meter reading is multiplied, if the heater uses more phases than is measured. For example, if the heater is a three-phase model and only one phase is measured, the reading is multiplied by 3. If all phases are measured that the heater is connected to set the value to 1.

**invalidReading**

Informs that the reading is invalid. Value must be greater than any reading ever can be, and be the same in the heater-reader and heater-control scripts.

**schedule**

Specifies how often the control cycle is performed. The parameter of interest is **timespec**, which specifies a cron job like interval.

Correct value depends on the operation of the electricity meter. In here, the electricity company records consumption every 15 minutes, so 5 minutes should ensure that if production drops below the required level while the heating is on, the net consumption should still be negative when the reading is taken.

## Heater-Control script

### Description

The heater-control script is the actual water heater controller. Heater-reader calls it at regular intervals with the readings it has collected and causes it to execute one control cycle.

Copy and paste the code into the second script slot (id 2) of the Shelly. Adjust script&apos;s CONFIG to match the environment.

### **CONFIG** parameters

Example:

```javascript
let CONFIG = {
  heatingTime: 180,   //Max. heating time (minutes)
  powerFull: 3500,    //Heater nominal power consumption
  powerPartial: 100,  //Lowered power exceptation
  
  //baseConsumption: 500, //For solar power metering, not used when net metering is used
  poweroffLevel: 1,       //Heater power consumption detection limit
  invalidReading: 9999,   //Greater than any reading ever could be
    
  homeEndpoint: 'http://192.168.2.14/cgi-bin/mittari_logger.cgi', //Leave empty '' if not in use
  kvsControlKey: 'readsetcompleted'
};
```

**heatingTime**

Maximum time the water is allowed to be heated, unless the heater&apos;s thermostat opens before that. When this time is up heating will be marked complete. (minutes)

**powerFull**

Heater&apos;s nominal power consumption (Watts)

**powerPartial**

Lowered power limit for use when there is not enough solar power to operate the water heater alone. Heating will switch on when generated solar power exceeds this limit and partial power period is active (see Reader CONFIG&apos;s **partialPowerBegins**). (Watts)

Example value is set so low that whenever the panels are producing some extra power, the heating turns on. Naturally, the rest of the energy is taken from the grid, but solar power at least reduces the heating bill.

**baseConsumption**

Household&apos;s average energy consumption without the water heater running. This value is subtracted from the solar power reading to prevent the heating turning on when there isn&apos;t enough solar energy to power it and the rest of the household at the same time. This setting is only used if the energy reading was retrieved using the *solar* keyname in the reader&apos;s config endpointlist. (Watts)

**poweroffLevel**

Water heater thermostat opening detection level. When the heater&apos;s measured consumption drops below this during heating, it means that the thermostat has opened and the heating can be marked as complete. (Watts)

**invalidReading**

Marker that the received reading is invalid. Value must be greater than any reading ever can be, and be the same in heater-reader and heater-control.

**homeEndpoint**

Home automation address where the script makes a json post containing a lot of interesting information. Leave empty *''* if not used.

**kvsControlKey**

Name of the key in KVS bank where the state of the heating is maintained (0 auto, 1 completed/manually stopped, 2 manually started). Keyname should not be changed.


# Running

Check that the scripts are configured correctly and their persistent mode is set. Start both scripts. Shelly&apos;s log window should show the scripts are starting, followed by their messages as they run. Do not set the *solar* and *netproduction* keynames at the same time to retrieve power readings, the netproduction value will overwrite the solar, and the extra query may also exceed Shelly's concurrent query limit.

Heater-reader installs a schedule, which in this example runs every 5 minutes. As long as the heating is unfinished, the script goes to collect new readings by the schedule and calls the heater-control script and passes it the values.

Heater-control installs an endpoint that listens for commands. When it receives a call it picks up the values the reader passes and runs a single control cycle. At the end of each cycle it sends a report to home automation endpoint (see parameter **homeEndpoint**) to tell how the heating is progressing (optional).

When heater-control detects that the heating time is full or the heater thermostat has opened, it marks the heating as complete by setting a value 1 (heating completed) to the key defined in **kvsControlKey** parameter. Heater-reader monitors this key, and when it sees this value value it stops calling endpoints and heater-control until the next morning. In the morning, heater-reader wakes up based on the time set in **dayBegins** setting, calls heater-control to reset all values, and a new heating cycle begins.

# Manual control via Shelly&apos;s KVS bank

## Description

In addition to automatic operation, heating can be manually started, stopped and switched back to automatic. It is done by setting a correct value to the key defined in **kvsControlKey** parameter. Similarly, the heater&apos;s state can be checked by reading the value of this key.

Manual control is useful in situations where automatic mode needs to be temporarily bypassed, eg. electricity from the panels is needed elsewhere and the heating has to be paused, or the forecast shows worsening weather and it is better to turn heater on now while there&apos;s more energy to harvest. 

In their simplest form, control commands can be urls in the browser&apos;s bookmark list. Fancier application would be a dedicated page on a home server, which could have nice buttons to send the commands and that could also display the state of the heater (by deciphering the json reports the control script sends to the **homeEndpoint** url).


## Control commands

**Note:**
- If heating is complete commands have no effect
- Command resets to automatic every morning
- Examples assume that the control key name is **readsetcompleted**
- Replace IP address in the examples with yours

### Start heating

Set KVS to **readsetcompleted: 2**

Heating starts and stays on, regardless of amount of solar power or the price of electricity. Thermostat opening or reaching the maximum heating time will cause the heating to finish like in automatic mode.

Example:
`http://192.168.2.10/rpc/KVS.Set?key="readsetcompleted"&value=2`

### Stop heating

KVS: **readsetcompleted: 1**

Heating stops, period. If it was stopped manually and not started again or switched to automatic, it will **not** be resumed until the next morning when the new heating cycle begins.

This value is also set when the heating completes.

`http://192.168.2.10/rpc/KVS.Set?key="readsetcompleted"&value=1`

### Automatic mode

KVS: **readsetcompleted: 0**

Default mode of operation. When heating is complete the value switches to **1**

`http://192.168.2.10/rpc/KVS.Set?key="readsetcompleted"&value=0`

# Power failure

The scripts should restart automatically after the power returns.

If heating was unfinished, it will start over because the heater-control lost track of the elapsed heating time.

If the heating completed before the power outage ( **readsetcompleted: 1** exists in the KVS bank), it will not start again.

# Observations

This system has been operating in its current form, except for the transition to HAN power metering, for over a year now, and has proven to be quite stable, withstanding power outages, LAN and Internet outages, and APIs that are down or returning garbage.



